---
layout: page
title: "Security"
comments: true
sharing: true
footer: true
---

* list element with functor item
{:toc}

# Overview

Application Security has 4 aspects:

* Authentication - proving user identity, often called user ‘login’.
* Authorization - access control
* Cryptography - protecting or hiding data from prying eyes
* Session Management - per-user time-sensitive state

## Core Concepts

{% img right /technology/shiro-basics.png %}

3 Main concepts in security

1. Subject - "the currently executing user". It could be more than a human user. e.g., daemon apps, 3rd party apps, etc.
2. SecurityManager - manages security operations for all users
3. Realm - acts the bridge/connector between the security provider and your application's security data like user accounts, access controls, etc.

# 1. Authentication

* Process of verifying a user's identity. Also called 'login' process.
* `Authentication Token = Principal(username) + Credential(password)`
* If the submitted credentials match what the system expects for that user identity (principal), the user is considered authenticated.

## Basic Authentication

Basic authentication is the simplest protocol available for performing authentication over HTTP. It involves sending a Base64-encoded username and password within a request header to the server. With Basic authentication (with and without SSL), your name and password do get automatically Base64- encoded.

The server checks to see if the username exists within its system and verifies the sent password. The client needs to send this Authorization header with each and every request it makes to the server.

### Unauthorized request

* The 401 response tells the client that it is not authorized to access the URI it tried to invoke on.
* The **WWW-Authenticate** header specifies which authentication protocol the client should use.
* In this case, **Basic** means basic authentication should be used. The realm attribute identifies a collection of secured resources on a website.

```http Response to an unauthorized request
 HTTP/1.1 401 Unauthorized
 WWW-Authenticate: Basic realm="CustomerDB Realm"
```

### Response with authorization details

* To perform authentication, the client must send a request with the Authorization header set to a Base64-encoded string of our username and a colon character, followed by the password. If our username is bburke and our password geheim, the Base64-encoded string of bburke:geheim will be `YmJ1cmtlOmdlaGVpbQ==`.
* The client needs to send this Authorization header with each and every request it makes to the server.

```http Request with authorization details
GET /customers/333 HTTP/1.1
Authorization: Basic YmJ1cmtlOmdlaGVpbQ==
```

**Downside**: The problem with this approach is that if this request is intercepted by a hostile entity on the network, the hacker can easily obtain the username and password and use it to invoke its own requests. Using an encrypted HTTP connection, HTTPS, solves this problem. With an encrypted connection, a rogue programmer on the network will be unable to decode the transmission and get at the Authorization header. Still, security-paranoid network administrators are very squeamish about sending passwords over the network, even if they are encrypted within SSL packets.

## Digest Authentication

Digest authentication was invented so that clients would not have to send clear text passwords over HTTP. It involves exchanging a set of secure MD5 hashes of the username, password, operation, URI, and optionally the hash of the message body itself. It is a hash value generated with the following pseudocode:

```http Unauthorized request
 GET /dir/index.html HTTP/1.0
 Host: localhost
```

```http Response to an unauthorized request
 HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest realm="CustomerDB Realm",
qop="auth,auth-int",
nonce="12dcde223152321ab99cd",
opaque="aa9321534253bcd00121"
```

The **nonce** and **opaque** attributes are special server-generated keys that will be used to build the subsequent authenticated request.

```http Hash calculating algorithm
H1 = md5("username:realm:password")
H2 = md5("httpmethod:uri")
response = md5("H1:nonce:nc:cnonce:qop:H2")
```

* The **nonce** and **opaque** attributes are a copy of the values sent with the earlier WWWAuthenticate header.
* The **uri** attribute is the base URI you are invoking on.
* The **nc** attribute is a request counter that should be incremented by the client with each request. This prevents hostile clients from replaying a request.
* The **cnonce** attribute is a unique key generated by the client and can be anything the client wants.
* The **response** attribute is where all the meat is. It is a hash value generated with the following pseudocode:


* When the server receives this request, it builds its own version of the **response** hash using its stored, secret values of the username and password. If the hashes match, the user and its credentials are valid.

```http Request with Authorization details
GET /customers/333 HTTP/1.1
Authorization: Digest username="bburke",
realm="CustomerDB Realm",
nonce="12dcde223152321ab99cd",
uri="/customer/333",
qop="auth",
nc=00000001,
cnonce="43fea",
response="11132fffdeab993421",
opaque="aa9321534253bcd00121"
```

### Pros

* The password is never used directly by the protocol. For example, the server doesn't even need to store clear text passwords. It can instead initialize its authorization store with pre-hashed values.
* Also, since request hashes are built with a nonce value, the server can expire these nonce values over time. This, combined with a request counter, can greatly reduce replay attacks.
When the server receives this request, it builds its own version of the response hash using its stored, secret values of the username and password. If the hashes match, the user and its credentials are valid.

### Cons

This approach is that unless you use HTTPS, you are still vulnerable to man-in-the-middle attacks, where the middleman can tell a client to use Basic authentication to obtain a password.  

## X.509 certificates

{% img right /technology/security-certs.gif %}


* HTTPS is not only an encryption mechanism - it can also be used for authentication.
* When you first interact with a secure website, your browser receives a digitally signed certificate from the server that identifies it.
* Your browser verifies this certificate with a central authority like VeriSign. This is how you guarantee the identity of the server you are interacting with and make
* sure you’re not dealing with some man-in-the-middle security breach.
* HTTPS can also perform two-way authentication. In addition to the client receiving a signed digital certificate representing the server, the server can receive a certificate that represents and identifies the client.
* When a client initially connects to a server, it exchanges its certificate and the server matches it against its internal store.
* Once this link is established, there is no further need for user authentication, since the certificate has already positively identified the user.

> SSL, or Secure Socket Layer, is a technology which allows web browsers and web servers to communicate over a secured connection. This means that the data being sent is encrypted by one side, transmitted, then decrypted by the other side before processing. This is a two-way process, meaning that both the server AND the browser encrypt all traffic before sending out data.

> Another important aspect of the SSL protocol is Authentication. This means that during your initial attempt to communicate with a web server over a secure connection, that server will present your web browser with a set of credentials, in the form of a "Certificate", as proof the site is who and what it claims to be. In certain cases, the server may also request a Certificate from your web browser, asking for proof that you are who you claim to be. This is known as "Client Authentication," although in practice this is used more for business-to-business (B2B) transactions than with individual users. Most SSL-enabled web servers do not request Client Authentication.

### Pros

Most secure way to perform authentication on web.

### Cons

Managing of the certificates is painful. The server must create a unique certificate for each client that wants to connect to the service. From the browser/human perspective, this can be a pain, as the user has to do some extra configuration to interact with the server.

## OpenAuth (OpenID)

...

# 2. Authorization

Authorization is essentially access control - controlling what your users can access in your application, such as resources, web pages, etc.

## Simple Access Control List (ACL)

* Roles/Users assigned with access to certain features. Users are assigned to roles. This model is not flexible since roles cannot be added dynamically
* Permissions are defined for features. Users are assigned permissions. This model allows dynamic addition of users.

## JSON Web Tokens

## SAML

# 3. Cryptography

Cryptography is the process of hiding or obfuscating data so prying eyes can’t understand it.

When a client is interacting with a RESTful web service, it is possible for hostile individuals to intercept network packets and read requests and responses if your HTTP connection is not secure.

Sensitive data should be protected with cryptographic services like SSL. The Web defines the HTTPS protocol to leverage SSL and encryption.

## Hashing (a.k.a Message Digest)

* Hashing/Message digests are secure one-way hash functions that take arbitrary-sized data and output a fixed-length hash value.
* `java.security.MessageDigest` class supports MD5 and SHA digests.
* Shiro supports hex-encode and Base64 encoding.

## Cipher

Ciphers are cryptographic algorithms that can reversibly transform data using a key. We use them to keep data safe, especially when transferring or storing data, times when data is particularly susceptible to prying eyes.

**Types**

* Public-Private key cipher
* AES 257-bit cipher

## Miscellaneous

* Kerberos - how it works
* PGP/GPG
* How to secure passwords - http://www.youtube.com/watch?v=6bR110r-RfY&list=WL08D7E897CDBD47CB (Salt, Bcrypt, Ascrypt, Blowfish algo, AES 256)

# 4. Session Management

Apache Shiro enables a Session programming paradigm for any application - from small daemon standalone applications to the largest clustered web applications. This means that application developers who wish to use sessions are no longer forced to use Servlet or EJB containers if they don’t need them otherwise.


# Bibliography

* Books
  * RESTful Java with JAX-RS - Chapter 12 - Securing JAX-RS
  * REST in practice - Chapter 9 - Web Security
* Links
  * [Application Security With Apache Shiro](http://www.infoq.com/articles/apache-shiro)
  * Java EE Security - http://docs.oracle.com/javaee/6/tutorial/doc/gijrp.html
  * Encyclopedia of Security - http://www.microsoft.com/mspress/books/sampchap/6429.aspx
