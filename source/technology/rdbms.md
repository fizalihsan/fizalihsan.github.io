---
layout: page
title: "RDBMS Concepts"
comments: true
sharing: true
footer: true
---

* list element with functor item
{:toc}

# Concepts

## Keys

> Refer to SQL Tips and Techniques-2002

* **Primary Key**
  * PK is an attribute or a set of attributes that uniquely identify a specific instance of an entity. 
  * PKs enforce entity integrity by uniquely identifying entity instances. 
* **Candidate Key** - an entity can have more than one attribute that can serve as a primary key. Any key or minimum set of keys that could be a primary key is called a candidate key. (Eg. EmpId, SSN, Name of an Employee entity) 
* **Alternate Key** - Rest of the non-primary keys are called alternate keys 
* **Composite Key** - A primary key made up of more than one attribute is known as a composite key 
* **Foreign Key**
  * is an attribute that completes a relationship by identifying the parent entity. 
  * Foreign keys provide a method for maintaining integrity in the data (called referential integrity) and for navigating between different instances of an entity. 
* **Surrogate Key** - system generated unique identifier. Not derived from application data.
  * UUID or GUID or Object Id (as in Mongo)
  * Sybase identity column `IDENTITY`
  * Oracle `SEQUENCE` or `GENERATED AS IDENTITY`
  * DB2 `AS IDENTITY GENERATED BY DEFAULT`
  * MySQL `AUTO_INCREMENT`

**Difference between a primary key and a unique key?**
Both primary key and unique enforce uniqueness of the column on which they are defined. But by default primary key creates a clustered index on the column, whereas unique key creates a nonclustered index by default. Another major difference is that, primary key doesn't allow NULLs, but unique key allows one NULL only. Identity columns & default values

## Integrity

* **Data integrity** - means, in part, that you can correctly and consistently navigate and manipulate the tables in the database. There are two basic rules to ensure data integrity; entity integrity and referential integrity. 
  * **Entity Integrity**- Entity integrity rule states that for every instance of an entity, the value of the primary key must exist, be unique, and cannot be null. 
  * **Referential Integrity**- rule states that every foreign key value must match a primary key value in an associated table. Referential integrity ensures that we can correctly navigate between related entities. FKs can have nulls.

### Constraints
* Constraints enable the RDBMS enforce the integrity of the database automatically, without needing you to create triggers, rule or defaults.
* **Types of constraints**: `NOT NULL`, `CHECK`, `UNIQUE`, `PRIMARY KEY`, `FOREIGN KEY` 
* **Check Constraints**
  * A check constraint is a type of integrity constraint in SQL which specifies a requirement that must be met by each row in a database table. The constraint must be a predicate. It can refer to a single or multiple columns of the table. The result of the predicate can be either `TRUE`, `FALSE`, or `UNKNOWN`, depending on the presence of `NULLs`. 
  * If the predicate evaluates to `UNKNOWN`, then the constraint is not violated and the row can be inserted or updated in the table. This is contrary to predicates in `WHERE` clauses in `SELECT` or `UPDATE` statements.

```sql Example check constraint
ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK ( predicate );

ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK ( PRICE > 100 AND DATE_INSERTED > CURRENT_DATE );
```

## Data Types

## Table Types

* **Heap-organized table** 
  * A heap-organized table is a table with rows stored in no particular order. This is a standard Oracle table; the term "heap" is used to differentiate it from an *index-organized table* or *external table*.
  * If a row is moved within a heap-organized table, the row's ROWID will also change

```sql
CREATE TABLE t1 (c1 NUMBER PRIMARY KEY, c2 VARCHAR2(30)) ORGANIZATION HEAP;
```

* **Index-organized Table (IOT)**
  * An index-organized table (IOT) is a type of table that stores data in a *B-Tree* index structure.
  * IOTs store rows in a B-tree index structure that is logically sorted in primary key order. 
  * Unlike normal primary key indexes, which store only the columns included in its definition, IOT indexes store all the columns of the table
  * Advantages
    * As an IOT has the structure of an index and stores all the columns of the row, accesses via primary key conditions are faster as they don't need to access the table to get additional column values.
    * As an IOT has the structure of an index and is thus sorted in the order of the primary key, accesses of a range of primary key values are also faster.
    * As the index and the table are in the same segment, less storage space is needed.
    * In addition, as rows are stored in the primary key order, you can further reduce space with key compression.
    * As all indexes on an IOT uses logical rowids, they will not become unusable if the table is reorganized.

```sql
CREATE TABLE my_iot (id INTEGER PRIMARY KEY, value VARCHAR2(50)) ORGANIZATION INDEX;
```
* **External Table**
  * An external table is a table that is NOT stored within the Oracle database. Data is loaded from a file via an access driver (normally ORACLE_LOADER) when the table is accessed. 
  * One can think of an external table as a view that allows running SQL queries against files on a filesystem without the need to first loaded the data into the database.

```sql
CREATE OR REPLACE DIRECTORY my_data_dir as '/my/data/dir/';
```

## LOB

## Cursors

* **Static Cursor** - Specifies that cursor will use a temporary copy of the data instead of base tables. This cursor does not allow modifications and modifications made to base tables are not reflected in the data returned by fetches made to this cursor. (Kind of like [snapshot iterators](technology/java-collections.html#fail-safe-iterators) in Java)
* **Dynamic Cursor**
  * Dynamic cursors are the opposite of static cursors. 
  * Dynamic cursors reflect all changes made to the rows in their result set when scrolling through the cursor. The data values, order, and membership of the rows in the result set can change on each fetch. All UPDATE, INSERT, and DELETE statements made by all users are visible through the cursor.  (Kind of like [weakly consistent iterators](technology/java-collections.html#fail-safe-iterators) in Java)
  * Updates are visible immediately if they are made through the cursor. 
  * Updates made outside the cursor are not visible until they are committed, unless the cursor transaction isolation level is set to read uncommitted.
* **Forward-ONLY Cursor** - Specifies that cursor can only fetch data sequentially from the first to the last row. FETCH NEXT is the only fetch option supported. 
* **KeySet Cursor** - 
  * Specifies that cursor uses the set of keys that uniquely identify the cursor's rows (keyset), so that the membership and order of rows in the cursor are fixed when the cursor is opened. SQL Server uses a table in tempdb to store keyset. 
  * The KEYSET cursor allows updates nonkey values from being made through this cursor, but inserts made by other users are not visible. 
  * Updates non-key values made by other users are visible as the owner scrolls around the cursor, but updates key values made by other users are not visible. If a row is deleted, an attempt to fetch the row returns an `@@FETCH_STATUS` of `-2`
* **Ref Cursors** - Cursor variables are like pointers to result sets. You use them when you want to perform a query in one subprogram, and process the results in a different subprogram (possibly one written in a different language). A cursor variable has datatype REF CURSOR, and you might see them referred to informally as REF CURSORs.
* **Implicit & Explicit cursors**
  * An implicit cursor is one created *automatically* for you by Oracle when you execute a query. 
  * An explicit cursor is one you create yourself. It takes more code, but gives more control - for example, you can just open-fetch-close if you only want the first record and don't care if there are others.

```sql Implicit cursor example
SELECT col INTO var FROM table WHERE something;
```

```sql Explicit cursor example
DECLARE   
  CURSOR cur IS SELECT col FROM table WHERE something; 
BEGIN
  OPEN cur;
  FETCH cur INTO var;
  CLOSE cur;
END;
```
### Disadvantages of cursors 
Each time you fetch a row from the cursor,it results in a network round trip, where as a normal SELECT query makes only one round trip, however large the resultset is. Further, there are restrictions on the SELECT statements that can be used with some types of cursors.

## Triggers

Triggers are special kind of stored procedures that get executed automatically when an INSERT, UPDATE or DELETE operation takes place on a table. Triggers can't be invoked on demand. They get triggered only when an associated action (INSERT, UPDATE, DELETE) happens on the table on which they are defined.

## Joins

{% img right /technology/visual_sql_joins.jpg 500 500 %}

* [A Visual Explanation of SQL Joins - Coding Horror](http://www.codinghorror.com/blog/2007/10/a-visual-explanation-of-sql-joins.html)
* http://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Fsqlp%2Frbafyjoin.htm 

* **Inner Join** (*ANSI supported*)
  * Records in both table A and table B where the given condition matches. e.g, `SELECT * FROM TableA INNER JOIN TableB ON TableA.name = TableB.name`
* **Cross Join** (*ANSI supported*)
  * Every possible pair of rows from both the tables. Basically a cartesian product
  * If no condition is provided in Inner join, then it becomes a cross join. e.g., `SELECT * FROM TableA CROSS JOIN TableB`
* **Left Outer Join** (*ANSI supported*)
  * produces a complete set of records from Table A, with the matching records (where available) in Table B. If there is no match, the right side will contain null.
  * e.g., `SELECT * FROM TableA LEFT OUTER JOIN TableB ON TableA.name = TableB.name`
* **Right Outer Join** (*ANSI supported*)
  * e.g., `SELECT * FROM TableA RIGHT OUTER JOIN TableB ON TableA.name = TableB.name`
* **Full Outer Join**  (*ANSI supported*)
  * Full Outer Join = Left Outer + Right Outer. e.g., `SELECT * FROM TableA FULL OUTER JOIN TableB ON TableA.name = TableB.name`
* **Outer Join**
  * Records NOT in table A and table B where the given condition matches. e.g, `SELECT * FROM TableA FULL OUTER JOIN TableB ON TableA.name = TableB.name WHERE TableA.id IS null OR TableB.id IS null `
* **Exception join** - A left exception join returns only the rows from the first table that do not have a match in the second table.
* **Equijoin** - 
* **Natural Join**- is an equijoin with redundant columns removed. 
* **Self Join** - 
* **Projection** - The project operator retrieves a subset of columns from a table, removing duplicate rows from the result.

## Join Algorithms

### Nested Loop Join 

{% img right /technology/nested-loop-join.gif 300 300 %}

* *when one table is small, and other table is large*
* **What is?** The nested loops join, also called nested iteration, uses one join input as the outer input table and one as the inner input table. The outer loop consumes the outer input table row by row. For every outer row, the inner loop searches for matching rows in the inner input table.
* In the simplest case, the search scans an entire table or index; this is called a **naive nested loops join**. 
* If the search exploits an index, it is called an **index nested loops join**. 
* If the index is built as part of the query plan (and destroyed upon completion of the query), it is called a **temporary index nested loops join**. (All these variants are considered by the query optimizer.)
* **When is it effective?** A nested loops join is particularly effective if the outer input is small and the inner input is preindexed and large. In many small transactions, such as those affecting only a small set of rows, index nested loops joins are superior to both merge joins and hash joins. In large queries, however, nested loops joins are often not the optimal choice.
* Block nested loop join???

### Merge Join / Sort-Merge Join

{% img right /technology/merge-join.gif 300 300 %}

* *when both the tables involved in the join are large*
* The merge join requires both inputs to be sorted on the merge columns, which are defined by the equality `ON` clauses of the join predicate. The query optimizer typically scans an index, if one exists on the proper set of columns, or it places a sort operator below the merge join. In rare cases, there may be multiple equality clauses, but the merge columns are taken from only some of the available equality clauses.
* Because each input is sorted, the Merge Join operator gets a row from each input and compares them. For example, for inner join operations, the rows are returned if they are equal. If they are not equal, the lower-value row is discarded and another row is obtained from that input. This process repeats until all rows have been processed.
* The merge join operation may be either a regular or a many-to-many operation. A many-to-many merge join uses a temporary table to store rows. If there are duplicate values from each input, one of the inputs will have to rewind to the start of the duplicates as each duplicate from the other input is processed.
* If a residual predicate is present, all rows that satisfy the merge predicate evaluate the residual predicate, and only those rows that satisfy it are returned.
* Merge join itself is very fast, but it can be an expensive choice if sort operations are required. However, if the data volume is large and the desired data can be obtained presorted from existing B-tree indexes, merge join is often the fastest available join algorithm.

### Hash Join

* *when the data set is large but the result set expected is small*
* This algorithm also has a startup penalty by forcing you to build a hash table of one of the input sets before the actual join can start. 
* Performance
  * Compared to the sort merge join this is easier as it involves only one sweep through the data and therefore the computational complexity is `O(n)` while sorting won't be better than `O(n log n)`. So in general you can build the hash faster than you would be able to do the sorting.
  * The hash also needs to be computed for only one input set and this could be the smaller one.
  * This makes the hash join often the preferred choice over the sort merge join.
* Generally speaking the hash join wins when you expect a large result set and the nested loop join wins when you expect a small result set. One of the most dominant problems in this area is the planner getting the estimates wrong and taking the other path.
* The hash join can only be used if you use equality as join relation.
* Building the hash needs temporary space and increasing work_mem sometimes helps.
* The hash join is also a good candidate for parallel processing. 

* [Joining in DB2](http://etutorials.org/Misc/advanced+dba+certification+guide+and+reference/Chapter+6.+The+DB2+Optimizer/Joining+in+DB2+UDB/)
* [Join Methods and Strategies](http://pic.dhe.ibm.com/infocenter/db2luw/v9r7/index.jsp?topic=%2Fcom.ibm.db2.luw.admin.perf.doc%2Fdoc%2Fc0005311.html)
* [Getting the Most from Hash Joins](http://www3.software.ibm.com/ibmdl/pub/software/dw/dm/db2/0208zubiri/0208zubiri.pdf)

# FAQs

* What's the difference between DELETE TABLE and TRUNCATE TABLE commands? 
  * DELETE TABLE is a logged operation, so the deletion of each row gets logged in the transaction log, which makes it slow. 
  * TRUNCATE TABLE also deletes all the rows in a table, but it won't log the deletion of each row, instead it logs the de-allocation of the data pages of the table, which makes it faster. Of course, TRUNCATE TABLE can be rolled back. 
* Co-related subquery? Co-related query is a query in which subquery depends on execution of main query 

```sql
Select DeptNo,Ename,Sal From Emp e1 Where Sal=(Select Max(Sal) From Emp e2 Where e1.DeptNo=e2.DeptNo)
```

* [How to select first/last/max per group in SQL?](http://www.xaprb.com/blog/2006/12/07/how-to-select-the-firstleastmax-row-per-group-in-sql)
* SQL query to get 4th or 5th maximum value from a table 

``` sql
select max(id) from EMP A where N=(select count(id) From EMP B where B.ID>=A.ID) 
OR 
select * from (select rownum rn,id from (select distinct id From EMP order by id desc)) where rn between N-1 and N;
```

* Difference between `USING` & `ON` clause in joins?
  * `USING` clause allows you to specify the join key by name.
  * `ON` clause allows you to specify the column names for join keys in *both tables*.
  * `ON` clause preserves the columns from each joined table separately, which the `USING` clause merges the columns from the joined tables into a single column. `USING` may not be a good idea when using outer joins where you would want to see unmatched rows from a table.

```sql
select department_name, city from departments
JOIN locations USING (location_id); -- specify the same column name for both of the tables for the join

select department_name, city from departments dept
join locations loc on (d.location_id = l.id); -- specify different column name for the tables for the join.
```

* When we need to use USING clause in the sql? For example in this below: 

```sql
SELECT emp_name, department_name, city FROM employees e 
JOIN departments d USING (department_id) 
JOIN locations l USING (location_id) WHERE salary > 10000;
```

* How to delete duplicate records in a table? 

``` sql
DELETE FROM test t1 WHERE EXISTS ( SELECT * FROM test t2 WHERE t2.col1=t1.col1 AND t2.rowid <> t1.rowid);
```

* What will be the output of this query? 
  * `SELECT 1 FROM DUAL UNION SELECT 'A' FROM DUAL;` The query would throw an error. The two data types in the union set should be same. Out here it is a 1 and 'A', datatype mismatch and hence the error.

* What does `UNION` do? What is the difference between `UNION` and `UNION ALL`?
  * `UNION` merges the contents of two structurally-compatible tables into a single combined table. 
  * The difference between `UNION` and `UNION ALL` is that `UNION` will omit duplicate records whereas `UNION ALL` will include duplicate records.
  * Performance-wise `UNION ALL` is typically be better than `UNION`, since `UNION` requires the server to do the additional work of removing any duplicates.

* What will be the result of the query below? Explain your answer and provide a version that behaves correctly?

```sql
select case when null = null then 'Yup' else 'Nope' end as Result;
```

This query will actually yield “Nope”, seeming to imply that `null` is not equal to itself! The reason for this is that the proper way to compare a value to `null` in SQL is with the `is` operator, not with `=`.

* What will be the result of the query below?

`SELECT * FROM runners;`

| id | name         |
|----|--------------|
|  1 | John Doe     |
|  2 | Jane Doe     |
|  3 | Alice Jones  |
|  4 | Bobby Louis  |
|  5 | Lisa Romero  |
   
`SELECT * FROM races;`

| id | event          | winner_id |
|----|----------------|-----------|
|  1 | 100 meter dash |  2        |
|  2 | 500 meter dash |  3        |
|  3 | cross-country  |  2        |
|  4 | triathalon     |  NULL     |

`SELECT * FROM runners WHERE id NOT IN (SELECT winner_id FROM races)`

Answer:
Surprisingly, given the sample data provided, the result of this query will be an empty set. The reason for this is as follows: *If the set being evaluated by the SQL `NOT IN` condition contains any values that are `null`, then the outer query here will return an empty set, even if there are many runner ids that match winner_ids in the races table*.

Knowing this, a query that avoids this issue would be as follows:

```sql
SELECT * FROM runners WHERE id NOT IN (SELECT winner_id FROM races WHERE winner_id IS NOT null)
```

* Given a table SALARIES, such as the one below, that has m = male and f = female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.

Answer: 

```sql
UPDATE SALARIES SET sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END
```

* Write a SQL query using `UNION ALL` (not `UNION`) that uses the `WHERE` clause to eliminate duplicates. Why might you want to do this?

Answer:
You can avoid duplicates using `UNION ALL` and still run much faster than `UNION` by running a query like this:

```sql
SELECT * FROM mytable WHERE a=X UNION ALL SELECT * FROM mytable WHERE b=Y AND a!=X
```

The key is the `AND a!=X` part. This gives you the benefits of the `UNION` command, while avoiding much of its performance hit.


* What are the `NVL` and the `NVL2` functions in SQL? How do they differ?

Both the `NVL(exp1, exp2)` and `NVL2(exp1, exp2, exp3)` functions check the value `exp1` to see if it is null.

With the `NVL(exp1, exp2)` function, if `exp1` is not null, then the value of `exp1` is returned; otherwise, the value of `exp2` is returned, but case to the same data type as that of `exp1`.

With the `NVL2(exp1, exp2, exp3)` function, if `exp1` is not null, then `exp2` is returned; otherwise, the value of `exp3` is returned.


# Bibliography

* Physical Database Design - The Database Professional's Guide to Exploiting Indexes, Views, Storage, and More
* Refactoring Databases
* SQL Anti-patterns
* http://www.geekinterview.com/articles/sql-interview-questions-with-answers.html